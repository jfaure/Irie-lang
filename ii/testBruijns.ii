-- (λB(2) (_+_ (_+_ (_+_ (Int 3) (Int 2)) B1) B0))
f = (\a b c d => add (add (add a b) c) d) 3 2 1 0

--ycomb f = (\x => f (x x)) (\x => f (x x))
--ycomb2 f = (\g => g g) (\x => f (x x))
rename x y = add x y

fg a w = case w of { @Wrap => add a a } -- i32 → [Wrap] → %i32
ff a (@Wrap) = add a a -- %i32 → [Wrap] → %i32
fg a w = case w of { @Wrap => add a a } -- i32 → [Wrap] → %i32
fh a (@Wrap x) = add x a -- i32 → [Wrap {%i32}] → %i32
--foldr1 f g = case g of
--  @Cons x xs => case xs of
--    @Nil => x
--    @Cons y ys => f x (foldr1 f xs)

-- free-var debruijn arithmetic
fv1 a b = (\c => div b a) @True
fv2 a b = (\c d => add a (div b c)) 0 1

t1 x = add x x
t2 = (\a b c d => add (add (add a b) c) d) 3 2 1 0
t3 x = (\a => add a x) 3
t4 x = (\y => (\z => x) 3) 2
t5 = \x => ((\b => b) x)
t6 = (\f => f) (\x y => add y 2) 3
t7 = \x => (\cond y => y) @Cond (@Done x 1)
t8 i = ((\cond => \a => a) 0) i -- (add i 1)
t9  = (\a b => (((\x y => @A (@B a x) (@C b y)) 3) 2)) 1 0
t10 = (\(@stream f b) => f b) (@stream (add 2) 3)
t11 x = (\a f => f a) x (\y => @Add x y)
t12 = (\f x y => f x y) add 3 2
--t13 = (\f x => f x) (\x y => add x y) 3 2

-- ycomb bruijn substitution?
--ycomb f = (\x => f (x x)) (\x => f (x x))
--ycomb2 f = (\g => g g) (\x => f (x x))

--free f = let g x = add f x in g
--free2 f1 f2 f3 = let g x = add f1 (add x f3) in g f2
--t1 x = let g y = let h z = add z (add x y) in h in g
--t2 x = let g y = { f1 = x , f2 = y } in 3
--t3 x = let g = { f1 = x , f2 = x } in 3


