import prelude
-- Fusion
-- sumAppend n = sum [m * m | m <- [1..n]]
-- = foldl _+_ 0 (concatMap (\m => pure (m * m)) (enum 1 n)
nextEnum n = case n >=? 10 of
  @True  => @Done
  @False => @Yield n (1 + n)

nextConcatMap i nest = case nest of
  @J (@Stream next s0) => case next s0 of
    @Done      => @Skip i @N
    @Skip s    => @Skip i (J (Stream next s))
    @Yield y s => @Yield y i (J (Stream next s))
  @N => case nextEnum i of
    Done   => Done
    Skip i => Skip i N
    Yield x i => let
      nextRet x = \case
        @True  => Yield (x * x) False
        @False => Done
      in Skip i (J (Stream (nextRet x) True))

go z s0 s1 = case nextConcatMap s0 s1 of
  @Done        => z
  @Skip s q    => go z s q
  @Yield x s q => go (z + x) s q

sumAppend n = go 0 n N

t = sumAppend 5
