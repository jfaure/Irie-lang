import prelude

Sfuse next (@stream n0 s0) = @stream (next << n0) s0
ana next seed = @stream next seed

-- foldr/l/dfa = only way to eliminate streams
foldrgo next c z s = case next s of
  @Done      => z
  @Skip r    => foldrgo next c z r
  @Yield x r => c x (foldrgo next c z r)
foldr c z (@stream next seed) = foldrgo next c z seed

foldlgo next f z s = case next s of
  @Done      => z
  @Skip r    => foldlgo next f z r
  @Yield x r => foldlgo next f (f z x) r
foldl f zz (@stream next seed) = foldlgo next f zz seed

Sappend (@stream nextL sl0) (@stream nextR sr0) =
  ana (SappendNext nextL nextR sr0) (@Left sl0)
SappendNext nextL nextR sr0 = \case
  @Left  sa => case nextL sa of
    @Done      => Skip    (Right sr0)
    @Skip s    => Skip    (Left s)
    @Yield x s => Yield x (Left s)
  @Right sb => case nextR sb of
    @Done      => Done
    @Skip s    => Skip    (Right s)
    @Yield x s => Yield x (Right s)

SconcatMap f (@stream nexta seed) =
  @stream (SConcatMapNext f nexta) {sa = seed , m = None}
SConcatMapNext f nexta S = case S . m of
  @None => case nexta S . sa of
    @Done      => Done
    @Skip s    => Skip { sa = s , m = @None}
    @Yield a s => Skip { sa = s , m = @One (f a)}
  @One (@stream nextb sb) => case nextb sb of
    @Done      => Skip    {sa = S . sa , m = @None}
    @Skip s    => Skip    {sa = S . sa , m = @One (stream nextb s)}
    @Yield b s => Yield b {sa = S . sa , m = @One (stream nextb s)}

fmap f = \case
  @Done      => Done
  @Skip r    => Skip r
  @Yield x r => Yield (f x) r
map = Sfuse << fmap

enumFromTo lo hi = ana (\i => if i >? hi then @Done else @Yield i (i + 1)) lo
_.._ { n0 } = enumFromTo

t = foldr add 0 (0 .. 10) --55
tt  = foldr add 0 (Sappend (enumFromTo 0 1) (enumFromTo 1 2)) --4
ttt = foldr add 0 (SconcatMap (enumFromTo 10) (enumFromTo 5 10))-- 10

-- foldl setBit 0 (scanl _+_ 0 lens)
-- f pats = _mm256_fromList_epi8 (concat pats) -- string concat
