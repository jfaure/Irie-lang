List =  type Π(0 : τ1) µa.[Nil | Cons {(λ0 : τ1) , ((recApp List λ0) : τ2)}]

Str =  type List (type %i8)

length = ∏ A → µa.[Nil | Cons {⊤ , a}] → (%i1 & %i32)

printList = ∏ A → µa.[Nil | Cons {%i32 , a}] → (%i1 & %i32)

scanSum = ∏ A → %i32 → A → µa.[Cons {%i32 , a}]

take = ∏ A B C → %i32 → µb.[Nil | Cons {A , b}] → µc.[Nil | Cons {A , c}]

drop = ∏ A B → %i32 → µa.([Nil | Cons {⊤ , a}] & B) → ([Nil] & B)

null = [Nil | Cons {⊤ , ⊤}] → %i1

singleton = ∏ A → A → [Cons {A , [Nil]}]

repeat = ∏ A B → A → µb.[Cons {A , b}]

xs = let ∏ A → µa.[Cons {⊥ , a}]

foldr = ∏ A B C → (A → B → B) → B → µc.[Nil | Cons {A , c}] → B

foldl = ∏ A B C → (A → B → A) → A → µc.[Nil | Cons {B , c}] → A

c = ∏ A B → A → B → [Cons {A , B}]

append = ∏ A B C → µb.[Nil | Cons {A , b}] → C → µc.[Cons {A , c}]

_++_ = ∏ A B C → µb.[Nil | Cons {A , b}] → C → µc.[Cons {A , c}]

concat = ∏ A B C D → µc.[Nil | Cons {µb.[Nil | Cons {A , b}] , c}] → µd.[Nil | Cons {A , d}]

consF = ∏ A B C → (A → B) → A → C → [Cons {B , C}]

mapFold = ∏ A B C D → (A → B) → µc.[Nil | Cons {A , c}] → µd.[Nil | Cons {B , d}]

map = ∏ A B C D → (A → B) → µc.[Nil | Cons {A , c}] → µd.[Nil | Cons {B , d}]

concatMap = ∏ A B C D E → (A → µc.[Nil | Cons {B , c}]) → µd.[Nil | Cons {A , d}] → µe.[Nil | Cons {B , e}]

unlines = ∏ A B C D → µc.[Nil | Cons {µb.[Nil | Cons {A , b}] , c}] → µd.[Nil | Cons {(%i8 & A) , d}]

unwords = ∏ A B C D E → µd.[Nil | Cons {µc.[Nil | Cons {A , c}] , d}] → µe.[Nil | Cons {(%i8 & A) , e}]

goUnwords = let ∏ A B C D → µc.[Nil | Cons {µb.[Nil | Cons {A , b}] , c}] → µd.[Nil | Cons {(%i8 & A) , d}]

unfoldr = ∏ A B C → (A → [Nothing | Just {{val : B , seed : A}}]) → A → µc.[Nil | Cons {B , c}]

filter = ∏ A B C → (A → %i1) → µb.[Nil | Cons {A , b}] → µc.[Nil | Cons {A , c}]

fromCString = ∏ A → %ptr(PrimInt 8) → µa.[Nil | Cons {%i8 , a}]

go = let ∏ A B → {!0 : %i1 , !1 : A , !2 : %ptr(PrimInt 8)} → µb.[Nil | Cons {(%i8 & A) , b}]

toCString = ∏ A B C → ((([Nil | Cons {A , B}] → {!0 : %i1 , !1 : A , !2 : B}) & C) → {!0 : %i1 , !1 : %i8 , !2 : C}) → C → %ptr(PrimInt 8)

unravel = let ∏ A B → [Nil | Cons {A , B}] → {!0 : %i1 , !1 : A , !2 : B}

splitAt = ∏ A B C → %i32 → µb.[Nil | Cons {A , b}] → {l : µc.[Nil | Cons {A , c}] , r : ([Nil] & b)}

z = ∏ A → {l : µa.[Nil | Cons {⊥ , a}] , r : [Nil]}

span = ∏ A B → (A → %i1) → µb.[Nil | Cons {A , b}] → {l : µb.[Nil | Cons {A , b}] , r : µb.[Nil | Cons {A , b}]}

s = ∏ A → {l : µa.[Nil | Cons {⊥ , a}] , r : µa.[Nil | Cons {⊥ , a}]}

reverse = ∏ A B C → µb.[Nil | Cons {A , b}] → µc.[Nil | Cons {A , c}]

scanl = ∏ A B C D → (A → B → A) → A → µc.[Nil | Cons {B , c}] → µd.[Nil | Cons {A , d}]

enumFromTo = ∏ A → %i32 → %i32 → µa.[Nil | Cons {%i32 , a}]

foldr1 = ∏ A B → (A → A → A) → µb.[Nil | Cons {A , b}] → A

nubBy = ∏ A B C → (A → A → %i1) → µb.[Nil | Cons {A , b}] → µc.[Nil | Cons {A , c}]

nub = let ∏ A B C D → µb.[Nil | Cons {A , b}] → µc.[Nil | Cons {A , c}] → µd.[Nil | Cons {A , d}]

elemBy = ∏ A B C → (A → B → %i1) → B → µc.[Nil | Cons {A , c}] → (%i1 & %i1)

