## ?
  * Linear variables (vbruijn | sourceArg | binding | literal | Extern [ | Field | Label ]) + occurs + src Info (all β-subbed with Term)
  * pap-spec spawns new specs under bindings (& new VBruijn args)
## Top Priority
  * switch to codeberg
  * Arg shapes -> a
  * conv Record | Sums to Vector with BitSet to map back to LNames/FNames & unify with module
  * Module = (Term.(Cons{} or Abs _ Cons{}) , ImportList , HNames , MixfixNames , LinSubs)
  * languageDocumentation.md
  * improve type annotations
  * toCStruct : {A} -> CStruct , fromCStruct : CStruct -> {A}
  * check escaped | leaked | dead vars are updated at right time through let-nests & mutuals
  * improve patterns2TT (add tuple of label) and eqn matches
  * normalize fields/labels for codegen (make sure order is predictable)
  * Function = Constructor + rewrite rules ?
  * ! mk all spec args VBruijns to maximise spec re-use
  * Instantiation & Generalisation is also beta-reduction and could be improved
  * in Label replace [Term] with Product field list
## Top
  * show (esp for repl JIT) + subtyping typeclasses
  * 'StrIntName' new datatype: growable vector + hashmap
  * Linear types; dependent types required to quantify relative linearity `Lin t ≥ Lin f => t → u`
  * expand lambda-mixfixes with explicit holes & don't allow unsaturated mixfix words
  * mixfix scope
  * record type decls
  * Intrinsics (eg. getFnName , getLine , getFile etc..)
## Parse
  * Pap object; allow inspection of papped args
  * don't allow mixing tabs and spaces
  * Pattern guards
  * improve linefolds
  * mutual let-bindings
## Types
  * THFieldCollision
  * Dependent normalisation
  * first class polymorphism
## Functor modules and records
  * Move THProduct to array and lookup via dichotomy
  * THProduct Vector alternative for ADTs when names sequential [n..m]
  * patterns in field assignments and top-level (patterns2TT)
  * imports allowed anywhere and treated as record
  * BindName LName FName overlap & mixfix FNames
  * Module = Fun | Record
  * Module = Vector Bind & [HNames] & [MixfixNames] (vs IntMap Expr)
  * Records = sparse array of file-scoped names
  * Open v qualified (BindNames v fieldNames)
  * pattern assignments `(a , b) = (1 , 3)`
  * scoping of labelNames
  * use functions & records to manage names? (names , let-binds , etc..)
## Error messages
  * Warn nonsense type joins / infer a dependent type
  * Unsaturated (incl. lone) mfWords that aren't ambig-binds should error
  * conflicting definitions (from pattern args , let bindings etc..)
  * mixfix parser errors & locations
## Beta-optimality:
  * Partial applications extracted and specialised for beta optimality
  * Fns passed as args must have an extra interpretable format

## Unimportant
  * List comprehensions
  * cache version
  * improve Generalise's handling of subbing a recvar with non-rec one (keep Recursive flag)
  * Pattern PTT: custom unPat function to support any patterns
  * optimise instantiation
  * avoid generalising type annotations; directly make a THBi rather than tvars
  * tycon let-bindings addresses (f = let l = .. in .. => `f.l`)
  * error messages via prettyprinter Doc
  * mergeTypes indicate whether merge was noop
  * check let-rec / mutual annotations
  * make work module import loops
  * language server
  * optimize cached modules
  * sh syntax `ls -lr` => `ls { l=True , r=True }` (Str2Label primitives?)
  * engineer GlobalResolver to work concurrently
  * prefetch memory | loop unrolling
  * mergetyhead could indicate if merge was a noop (so bisub knows it has already seen that input)
  * Completion based on types (Type -> Bind)
  * after function with no free-vars generalised, can trim but not fully clear bisubs!
