# Libs Lens List Eff BitSet ; DFA NFA glushkov Charscan
# captures inside inExprs are inacurrate (They are a pdep of their freeVars)!
# open modules / records (qualify names on it?)
## Top Priority (PathNames , cross-level mutuality , machine-code)
  * module import-sig (will help with mutual modules)
  * subtypes: Identity Iso "a <: Identity a" "Identity a <: a" & typeClass dict "{ ret : A } <: A"
  * leaf bicasts ; subtype tycon trees (traversals)
  * Case call stream.next to recover nice syntax (? subtype @stream to open top layer)
  * WrappedSimpleMutual.g1 should not have polymorphic type (mutual generalistation bug)
  * Identify recons (cons over matches) and rewrite to Lens insert / modify
  * generalise all lambda types (unless inlineable?) + check not-recursive (avoid inf β-reduction eg. Y-comb)
  * label/constant name-conv: importing new labels can break code: eg. f a = _ ; then import an 'a' label
  * edit-distance
## New primitives + Syntax
  * '.' , reservedChar for "r.f" , but want ".&." , ".." names => reserve '.' but words can start with "."?
  * ~> = implicit arg: A ~> A -> A ; ~ for app of implicit: "identity ~Int 3"
  * quantify over fields / labels (dependent type)
     decomp : Label A -> [A _ | ..] -> ([A _] , [..])
  * record type syntax: { x = Int , y } -- indicates y = ? (only makes sense as a type, but legal syntax)
  * record union (| : |) , difference (\\ : \\)
  * `$ ls -l --reverse`: '$' runs opt-parse on text to end-of-line
  * scope of field/label names: topnames or label names?
      {x = 3} . x .~ "hello" -- { x : Int } -> { x : String }
  ? Sum-of-Record
  ? argCase => f = \argCase { a b => _ }
### Linearity ; free variables (type must be known) ; β vs always-inline
  ! β-opt: Specialise on paps iff dupd (or all paps?) (polymorphic functions may miss pap-specs)
  * dup node scope: global / device / thread ?
      f x = x x => f x = let a b = DUP x in a b
      ! see when lambdas are duplicated (also reduce computations on free-vars when papped)
  ? compute containement
## Notes. Modules / records
  export list & bind Import list
  Cap field number to 64 (use pdep to mark subtyping frets), large records mk list
  Eraser argument is a form of function subtyping
  add-specs to imported binds
  unInline case-branch lambdas
  open / required (also locally)
  record-field patterns ((a , b) = rhs) => (\case { (a , b) => rhs })
    ? need to case over whole record since lhs is in scope mutually
  * sealing (effect): module becomes only accessible through its signature
  ? mutual functions within separate records = eg. let a = { f = b.g } ; b = { g = a.f }
  * Mutual modules = (λimports -> λM[m1 , m2] -> (m1 , m2)) i1..in M1 M2
  * record-field patterns: ? make mutual λ over whole record -- (f , g) = (2 , 3)
  * type/term scope; Idris: (names bound in types are also bound as @-patterns)
    vlength : {n : Nat} -> Vect n a -> Nat
    vlength _ = n
## !?
  * short-circuit fns: _&&_
  * named arguments (perhaps by subtype from a record arg)
  * shared streams (eg. MUL)
  * derived streams: splitAt creates 2 streams from 1, but the second is only available after the first
  * dynamic fuse pap: (+1) << (+1) => (+2)
  * type application (eg. perfect tree) `PTree a = Leaves a | Cons (PTree (a , a))` (μ insufficient here)
  * Sum of record [l : { f : int } | l2 : { f : int }] <: { f : int }
  * expand lambda-mixfixes with explicit holes
  * mixfix re-arrange let-ins `if y then let x = 3 in x else y` (Juxt x else y) or (; Juxt else y)
## Parse / Pretty
  * pat guards
  * lambda case type annotation: \case : scrut -> ret
  * Parse Intrinsics (eg. readConstFile , getFnName , getSourceLine , getSourceFile etc..)
  * repl parser: multiline case / let
  * pretty case-case formats wrong
## Types
  * Ad-hoc polymorphism: `Int <: [ NumInt Int ]` show (esp for repl JIT) (? mempty : Monoid a => a)
  * THFieldCollision
  * Dependent normalisation
  * first class polymorphism: eg. require instantiating with polytypes
    '<<' in let f : [a] -> [a] -> Int ; g : Bool -> [a] -> [a] in f << g
  * Linear types; dependent types required to quantify relative linearity `Lin t >= Lin f => t -> u`
## Beta-optimality: Specialise paps (tough to detect paps on polymorphic data)
  * SOA data
  * λ Minimise normal forms: λ-encoding + lifting + sharing
  * λ-lifting: if all subterms of App or Match share λ, lift it
  * case-splitters as data for runtime optimisation
  * Partial applications extracted and specialised for beta optimality
  * fns that do case-splits lazy in arguments they may not need
## Error messages
  * Warn nonsense type joins | dependent case?
  * mixfix parser errors & locations
  * Literal is out of Int range: cast Literals
## Unimportant
  * Use System.OsPath instead of FilePath: System.File.OsPath.readFile
  * let-scope depends on mixfix parse: "letscopeAfterMixfix y = if y then let x = 3 in x else y"
  * mode to print type-var bounds
  * Insta-unwrap/specialise single branch cases
  * Completion based on types (Type -> Bind)
  * tabs vs spaces
  * Termination checker, if a Refl type diverges it proves nothing
  * strictly positive recursion
  * underdetermined recursion: https://counterexamples.org/underdetermined-recursion.html
    equirecursive => A = F[A] ; B = F[B] => A = B (unsound for arbitrary type-level functions F!)
    if multiple solutions for X = F X; eg. F X = X ; A = Int ; B = String
  * don't assume injectivity! (or. distinguish between type constructors and type-functions)
  * equality constraints are central to GADTs `Gabriel Scherer and Didier Rémy. GADTs meet subtyping.` `https://okmij.org/ftp/ML/first-class-modules/#GADT`
  * switch to codeberg
  * List comprehensions
  * cache version
  * Allow dynamic inspection of papped args
  * Pattern PTT: custom unPat function to support any patterns eg. `fact (<? 2) = 1`
  * error messages via prettyprinter Doc
  * language server
  * mergetyhead indicates if merge was a noop (so bisub knows it has already seen that input)
  * after function with no free-vars generalised, can trim but not fully clear bisubs!
  * Function = Constructor + rewrite rules ?
  * `typeOf : (t : Type) -> Type` shortcut to access (and alias) an inferred type
  * surround notes: cs"' cs'<q> cst" ds" ysiw] cs]{ yssb ds{ds) ysiw<em>
  * https://documentation.divio.com/
  * phase distinction: meaning of static expr not dependent on executing dynamic exprs
