## meta
  * surround notes: cs"' cs'<q> cst" ds" ysiw] cs]{ yssb ds{ds) ysiw<em>
  * https://documentation.divio.com/
  * move to f2fs
## ?
  * track branch freevars
  * type application, esp. perfect tree
  * subtype sum of record = [l : { f : int } | l2 : { f : int }] <: { f : int }
  * open sum type (default case branch)
  * audit oldcachedmodule , seems slightly broken (probably BindOpt) , also bring labels in scope
  * make freevars explicit in let-binds so their types make sense
  * trim bisubs
## Top Priority
  * Pat must be Term: mixfix patterns; mixfix labels vs mixfix binds ≫ parse TT ≫ VExtern ≫ new VArg | VBruijns ≫ invert into case-tree
  * cata defined with let doesn't generalise (is recursive let-bound problematic?)
  * fix let-bind scopes (let-bound names are in global scope)
  * mutuals ⇒ recurse over product category
  * (Tuple ?) , toCStruct : {A} -> CStruct , fromCStruct : CStruct -> {A}
  * improve Main: explicit pipeline
## Parse
  * allow tabs instead of spaces
  * Pattern guards
  * Parse Intrinsics (eg. getFnName , getSourceLine , getSourceFile etc..)
  * figure out end of let-in in mixfix parser ?! `if y then let x = 3 in x else y` (Juxt x else y) or (; Juxt else y)
  * repl parser: multiline case / let
  * expand lambda-mixfixes with explicit holes
## Types
  * Annotations (record , sum , TPi)
  * Ad-hoc polymorphism: `Int <: [ NumInt Int ]` show (esp for repl JIT)
  * THFieldCollision
  * Dependent normalisation
  * first class polymorphism
  * Linear types; dependent types required to quantify relative linearity `Lin t ≥ Lin f => t → u`
  * splitAt with Nils should also simplify
## Functor modules and records (infer a module as a TT (Abs | Record) + ImportList , HNames , MixfixNames , LinSubs)
  * file = implicit `filename = record`
  * pattern assignments `(a , b) = (1 , 3)`
  * file = let-block = opened record (allow use/open/mutual statements)
  * BindName LName FName MFName overlap
  * use | open | mutual allowed in let-blocks / opened record
  * scoped HNames = path <.> field
  * Linear variables (vbruijn | sourceArg | binding | literal | Extern [ | Field | Label ]) + occurs + src Info (β-subbable with Term)
  ? scope | dependency graph: imports / records / let-bindings / labelNames(!)
  ? imported names as inputs to the module?
  ? file | module (inter-)dependencies
  ? not evaluated args eg. `if_then_else_` dependently evaluates/needs each arg
## Beta-optimality:
  * λ Minimise normal forms on composition: Lambda encoding + lifting + sharing
  * case-splits as data
  * Partial applications extracted and specialised for beta optimality
  * Fns passed as args must have interpretable format
## SSA
  * local/extern names in ssa form
  * normalize order of fields/labels for codegen (sort on size then textual name)
## Error messages
  * Warn nonsense type joins | infer a dependent type
  * conflicting definitions (from pattern args , let bindings etc..)
  * mixfix parser errors & locations
  * Literal is out of Int range
## Unimportant
  * strictly positive recursion
  * underdetermined recursion: https://counterexamples.org/underdetermined-recursion.html
    equirecursive ⇒ A = F[A] ; B = F[B] ⇒ A = B (unsound for arbitrary type-level functions F!)
    if multiple solutions for X = F X; eg. F X = X ; A = Int ; B = String
  * the avoidance problem (types about to go out of scope)
  * don't assume injectivity!
  * Need totality checker, else a Refl type may not terminate and thus not prove EQ
  * Advanced recursive types µ insufficient `PTree a = Leaves a | Cons (PTree (a , a))`
  * equality constraints are central to GADTs `Gabriel Scherer and Didier Rémy. GADTs meet subtyping.` `https://okmij.org/ftp/ML/first-class-modules/#GADT`
  * math2 = 1 + 2 * 3 + 4 -- should be: (1 + (2 * 3)) + 4
  * upgrade mu-merge to modify varsubs table
  * switch to codeberg
  * Instantiation & Generalisation is also beta-reduction and could be improved
  * List comprehensions
  * cache version
  * Allow inspection of papped args
  * BitSetMap upgrades for [0..64] and sequential names [n..m]: rm Tuple
  * Pattern PTT: custom unPat function to support any patterns eg. `fact (<? 2) = 1`
  * avoid generalising type annotations; directly make a THBi rather than tvars
  * tycon let-bindings addresses (f = let l = .. in .. => `f.l`)
  * error messages via prettyprinter Doc
  * mergeTypes indicate whether merge was noop
  * check let-rec / mutual keyword (emit warning if not present)
  * make work module import loops
  * language server
  * optimize cached modules
  * sh syntax `ls -lr +x` => `ls { l=False , r=False , x=True }` (Str2Label primitives?)
  * engineer GlobalResolver to work concurrently
  * mergetyhead could indicate if merge was a noop (so bisub knows it has already seen that input)
  * Completion based on types (Type -> Bind)
  * after function with no free-vars generalised, can trim but not fully clear bisubs!
  * optimise co-occurences by merging instantly
  * 'StrIntName' new datatype, during parsing link growable vector + hashmap
  * Function = Constructor + rewrite rules ?
  * replace fnSig with typedTT
  * `typeOf : (t : Type) -> Type` shortcut to access (and alias) an inferred type
