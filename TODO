## meta
  * surround notes: cs"' cs'<q> cst" ds" ysiw] cs]{ yssb ds{ds) ysiw<em>
  * https://documentation.divio.com/
## Let (record) as Bruijn; VLetBind is + , VBruijn -
  * write specs to Bind
  * Lazy-gen => iff top-level / duplicated (also escaped vars)
  * mutual   => generalise together
  * rewrite lambda application to let-bind, since it needn't guess its arg types and dupd args must be generalised
## Top Priority (PathNames , cross-level mutuality , machine-code)
  * label-scope bug: file-local labels in module2 are considered not-in-scope if cached (new '@' labels vs imported)
  * mode to print type-var bounds
  * cross-module mixfixes broken
  * Interpret
  * Free-vars
  * fix cache
  * μ-roll multi-branch μs merge; μ-roll needs rewrite
  * Unpattern multi-args: SSfuse next (@stream n0 s0) = @stream (next << n0) s0
## Names + meta
  * make global resolver more like a standard module
    atm. AllBinds = QName -> (HName , Bind) ; Externs assumes module = [(HName , Expr)]
  ? dependency graph | arg,bind linearity
  * UpName = (depth , nm)
  * DownName = [nm]; each index contextualised by count
  * Transitive deps may require IO / aggressive preloading
## ?
  * FEnv must identify recons (cons over matches) and rewrite to Lens insert / modify
  * FEnv make dup nodes so MC can assume everything is linear
  * derived functions: specs / β-rewritings as terms under main function
  * type application (eg. perfect tree) `PTree a = Leaves a | Cons (PTree (a , a))` (μ insufficient advanced recursion)
  * subtype sum of record = [l : { f : int } | l2 : { f : int }] <: { f : int }
  * open sum type (default case branch)
  * trim bisubs
  * expand lambda-mixfixes with explicit holes
  * mixfix re-arrange let-ins `if y then let x = 3 in x else y` (Juxt x else y) or (; Juxt else y)
  * make solveScopes an anamorphism (need to delay solvemixfixes to infer)
  * lambdas name-scope are leaking out
## Parse
  * pat guards
  * typed lambda case: \case : scrut -> ret
  * Parse Intrinsics (eg. getFnName , getSourceLine , getSourceFile etc..)
  * repl parser: multiline case / let
## Types
  * Annotations (record , sum , TPi)
  * Ad-hoc polymorphism: `Int <: [ NumInt Int ]` show (esp for repl JIT)
  * THFieldCollision
  * Dependent normalisation
  * first class polymorphism:
      eg. require instantiating << with polytype => let f : [a] -> [a] -> Int ; g : Bool -> [a] -> [a] in f << g
  * Linear types; dependent types required to quantify relative linearity `Lin t >= Lin f => t → u`
## Beta-optimality:
  * λ Minimise normal forms: λ-encoding + lifting + sharing (if subterms of App or Match contain λ, lift them)
  * case-splitters as data for runtime optimisation
  * Partial applications extracted and specialised for beta optimality
  * Fns passed as args must have interpretable format
  * fns that do case-splits lazy in arguments they may not need
## Error messages
  * Warn nonsense type joins | infer a dependent type
  * conflicting definitions (from pattern args , let bindings etc..)
  * mixfix parser errors & locations
  * Literal is out of Int range
## Unimportant
  * tabs v spaces
  * Need totality checker, else a Refl type may not terminate and thus proves nothing
  * optimise tycons to avoid level retraversal
  * strictly positive recursion
  * underdetermined recursion: https://counterexamples.org/underdetermined-recursion.html
    equirecursive => A = F[A] ; B = F[B] => A = B (unsound for arbitrary type-level functions F!)
    if multiple solutions for X = F X; eg. F X = X ; A = Int ; B = String
  * the avoidance problem (types about to go out of scope)
  * don't assume injectivity!
  * equality constraints are central to GADTs `Gabriel Scherer and Didier Rémy. GADTs meet subtyping.` `https://okmij.org/ftp/ML/first-class-modules/#GADT`
  * switch to codeberg
  * List comprehensions
  * cache version
  * Allow inspection of papped args
  * Pattern PTT: custom unPat function to support any patterns eg. `fact (<? 2) = 1`
  * avoid generalising type annotations; directly make a THBi rather than tvars
  * tycon let-bindings addresses (f = let l = .. in .. => `f.l`)
  * error messages via prettyprinter Doc
  * check let-rec / mutual keyword (emit warning if not present)
  * make work module import loops => read the files simultaneously
  * language server
  * optimize cached modules
  * sh syntax `ls -lr +x` => `ls { l=False , r=False , x=True }` (Str2Label primitives?)
  * engineer GlobalResolver to work concurrently
  * mergetyhead indicates if merge was a noop (so bisub knows it has already seen that input)
  * Completion based on types (Type -> Bind)
  * after function with no free-vars generalised, can trim but not fully clear bisubs!
  * optimise co-occurences by merging instantly
  * Function = Constructor + rewrite rules ?
  * `typeOf : (t : Type) -> Type` shortcut to access (and alias) an inferred type
  * treat module QNames as bruijn args and β-reduce them optimally?
