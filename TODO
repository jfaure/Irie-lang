# Lift all Let-Ins
# Effects
# judge bind append
# Type aliases
  * mutumorphism: (f1 Δ f2) as input (Requires special construct to avoid β-reduce loop)
    Also ensure β-reduction doesn't rm the let-bind wrapper prematurely
  ? opened modules
  ? Nest QNames (also local modules/namespaces) vs module QNames in types (also let-bound mixfixes)
  ? Opened name vs projection name
  * letscope depends on mixfix parse
## Top Priority (PathNames , cross-level mutuality , machine-code)
  * Conv non-mut non-rec let-binds straight to fn args
  * leaf bicasts ; subtype tycon trees
  * Case call stream.next to recover nice syntax (? subtype @stream to open top layer)
  * WrappedSimpleMutual.g1 should not have polymorphic type (mutual generalistation)
  * Identify recons (cons over matches) and rewrite to Lens insert / modify
  * generalise all lambda types (unless inlineable?) + check not-recursive (avoid inf β-reduction eg. Y-comb)
  * cross-module mixfixes broken
  * trim bisubs at some point
  * check if capture free-vars correctly on mutual bindings
  * Use System.OsPath instead of FilePath: System.File.OsPath.readFile
  * importing new labels can break code: eg. f a = _ ; then import an 'a' label
  * edit-distance
## Syntax
  * Array type: "# 1 3 2 : Array Int"
  * import lists: imports / opens keywords
  * `$ ls -l --reverse`: $ run opt-parse on a string
  * record type syntax: { x : Int , y } -- indicates y : _
  ? implicit args: {} used already
  ? Sum-of-Record
### Linearity ; free variables (type must be known) ; β vs always-inline
  ! β-opt: Specialise on paps iff dupd (or all paps?) (polymorphic functions may miss pap-specs)
  * dup node scope: global / device / thread ?
      f x = x x => f x = let a b = DUP x in a b
      ! see when lambdas are duplicated (also reduce computations on free-vars when papped)
  ? should we compute containement
## Notes. Modules / records
  ? export list & bind Import list
  Cap field number to 64 (use pdep to mark subtyping frets), large records mk list
  Eraser argument is a form of function subtyping
  Generalise top-level & duplicated lambdas (inline the rest)
  new specs for imported binds
  linearity
  unInline case-branch lambdas
  open / required (also locally)
  record-field patterns ((a , b) = rhs) => (\case { (a , b) => rhs })
    ? need to case over whole record since lhs is in scope mutually
  ? mutual functions within separate records =eg. let a = { f = b.g } ; b = { g = a.f }
  Mutual modules = (λimports -> λM[m1 , m2] -> (m1 , m2)) i1..in M1 M2
  * sealing (effect): module becomes only accessible through its signature
  ? mutual functions within separate records = eg. let a = { f = b.g } ; b = { g = a.f }
  * Mutual modules = (λimports -> λM[m1 , m2] -> (m1 , m2)) i1..in M1 M2
  * applications of insane functions must be fully applied
  * record-field patterns: ? make mutual λ over whole record -- (f , g) = (2 , 3)
  * type/term scope; Idris: (names bound in types are also bound as @-patterns)
    vlength : {n : Nat} -> Vect n a -> Nat
    vlength _ = n
## !?
  * short-circuit fns: _&&_
  * named arguments (perhaps by subtype from a record arg)
  * shared streams (eg. MUL)
  * derived streams: splitAt creates 2 streams from 1, but the second is only available after the first
  * dynamic fuse pap: (+1) << (+1) => (+2)
  * type application (eg. perfect tree) `PTree a = Leaves a | Cons (PTree (a , a))` (μ insufficient here)
  * Sum of record [l : { f : int } | l2 : { f : int }] <: { f : int }
  * open sum type (default case branch)
  * expand lambda-mixfixes with explicit holes
  * mixfix re-arrange let-ins `if y then let x = 3 in x else y` (Juxt x else y) or (; Juxt else y)
## Parse / Pretty
  * pat guards
  * lambda case type annotation: \case : scrut -> ret
  * Parse Intrinsics (eg. readConstFile , getFnName , getSourceLine , getSourceFile etc..)
  * repl parser: multiline case / let
  * pretty case-case formats wrong
## Types
  * mode to print type-var bounds
  * Ad-hoc polymorphism: `Int <: [ NumInt Int ]` show (esp for repl JIT) (? mempty : Monoid a => a)
  * THFieldCollision
  * Dependent normalisation
  * first class polymorphism: eg. require instantiating with polytypes
    '<<' in let f : [a] -> [a] -> Int ; g : Bool -> [a] -> [a] in f << g
  * Linear types; dependent types required to quantify relative linearity `Lin t >= Lin f => t -> u`
## Beta-optimality:
  * SOA data
  * λ Minimise normal forms: λ-encoding + lifting + sharing (if subterms of App or Match contain λ, lift them)
  * case-splitters as data for runtime optimisation
  * Partial applications extracted and specialised for beta optimality
  * Fns passed as args must have interpretable format
  * fns that do case-splits lazy in arguments they may not need
## Error messages
  * Warn nonsense type joins | infer a dependent type
  * conflicting definitions (from pattern args , let bindings etc..)
  * mixfix parser errors & locations
  * Literal is out of Int range
## Unimportant
  * Insta-unwrap/specialise single branch cases
  * optimise strbuf and literal string/arrays
  * Completion based on types (Type -> Bind)
  * tabs vs spaces
  * Need totality checker, else a Refl type may not terminate and thus proves nothing
  * strictly positive recursion
  * underdetermined recursion: https://counterexamples.org/underdetermined-recursion.html
    equirecursive => A = F[A] ; B = F[B] => A = B (unsound for arbitrary type-level functions F!)
    if multiple solutions for X = F X; eg. F X = X ; A = Int ; B = String
  * don't assume injectivity! (or. distinguish between type constructors and type-functions)
  * equality constraints are central to GADTs `Gabriel Scherer and Didier Rémy. GADTs meet subtyping.` `https://okmij.org/ftp/ML/first-class-modules/#GADT`
  * switch to codeberg
  * List comprehensions
  * cache version
  * Allow dynamic inspection of papped args
  * Pattern PTT: custom unPat function to support any patterns eg. `fact (<? 2) = 1`
  * error messages via prettyprinter Doc
  * language server
  * optimize cached modules
  * mergetyhead indicates if merge was a noop (so bisub knows it has already seen that input)
  * after function with no free-vars generalised, can trim but not fully clear bisubs!
  * Function = Constructor + rewrite rules ?
  * `typeOf : (t : Type) -> Type` shortcut to access (and alias) an inferred type
  * reinstate ArgProd f97cd9c0d01eddb562a029fa52ddee785e6a47b6
  * surround notes: cs"' cs'<q> cst" ds" ysiw] cs]{ yssb ds{ds) ysiw<em>
  * https://documentation.divio.com/
  * phase distinction: meaning of static expr not dependent on executing dynamic exprs
