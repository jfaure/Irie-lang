## Top Priority (PathNames , cross-level mutuality , machine-code)
  * Fix case-case: inverted λ (? this may push free-vars out)
  * How to duplicate stream but share computations
  * type aliases + term/type name scope (global?)
  * Identify recons (cons over matches) and rewrite to Lens insert / modify
  * generalise all lambda types (unless inlineable?) + check not-recursive (avoid inf β-reduction eg. Y-comb)
  * ? can remove QBind ? perhaps "module = let imports in" allows writing specialisations for imports
  * label-scope bug: file-local labels in module2 are considered not-in-scope if cached (new '@' labels vs imported)
  * cross-module mixfixes broken
  * rewrite μ-roll; esp. for multi-branch μs merge
  * trim bisubs at some point
  * check if capture free-vars correctly on mutual bindings
### Linearity ; free variables (type must be known) ; β vs always-inline
  ! β-opt: Specialise on paps iff dupd (transitive dups?) => extract any functions on the papped arguments
  ? assume linear
  * explicit freeVars within lets + dup nodes + type application; also half-generalised (escaped vars) types
  * dup node: (hangs on global (device / thread ?) scope)
      f x = x x => f x = let a b = DUP x in a b
      ! see when lambdas are duplicated (also reduce computations on free-vars when papped)
  ? should we compute containement
  Generalise lams passed into functions that duplicate args
  GlobalResolver = { Modules } BitSetMap of modules keyed on INames
  Module : (λimportBruijns -> {}) i1..in
  Modules arguments (imports) are themselves λ applied to transitive imports
  ? trans-deps ; open/require ; record-field pattern ; update-spec
  LetArg = LetArg { open : Bool , rhs : _ }
  module is given all its imports as LetArg debruijn arguments
    solveScopes qualifies all names on LetArg imports (VBruijn x . name) => build bitset of used fields for +VBruijns
    opened = bruijn name all fields => linearity will show the dep-tree
# Mutuality: insane Π = λM[a , b] -> (a , b) => 
  ? mutual functions within separate records =eg. let a = { f = b.g } ; b = { g = a.f }
  Mutual modules = (λimports -> λM[m1 , m2] -> (m1 , m2)) i1..in M1 M2
## Notes. Let (record) as Bruijn (generalise duplicated arguments & mutual fn args)
  ? export list
  ? Cap field number to 64 for cheaper subtyping with i64 bitset
  let-App = sv mutual info
  BruijnSub = Either Int Bind  -- VBruijn typevar | Bind
  Let-App = BruijnApp 1 Binds  -- Eraser argument is a form of function subtyping
  Generalise top-level & duplicated lambdas (inline the rest)
  new specs for imported binds
  linearity
  DownName = [nm]; each index capped by bruijn n
  unInline case-branch lambdas
  open / required (also locally) | dependency graph vv
  Transitive deps may require IO / aggressive preloading eg. True, builtins => prelude => import prelude
  record-field patterns ((a , b) = rhs) => (\case { (a , b) => rhs })
    ? need to case over whole record since lhs is in scope mutually
  ? let-bound labels
  atm. AllBinds = QName -> (HName , Bind) ; Externs assumes module = [(HName , Expr)]
## !?
  * named arguments (perhaps by subtype from a record arg)
  * shared streams (eg. MUL)
  * derived streams: splitAt creates 2 streams from 1, but the second is only available after the first
  * dynamic fuse pap: (+1) << (+1) => (+2)
  * subtype tycon trees
  * type application (eg. perfect tree) `PTree a = Leaves a | Cons (PTree (a , a))` (μ insufficient here)
  * Sum of record [l : { f : int } | l2 : { f : int }] <: { f : int }
  * open sum type (default case branch)
  * expand lambda-mixfixes with explicit holes
  * mixfix re-arrange let-ins `if y then let x = 3 in x else y` (Juxt x else y) or (; Juxt else y)
## Parse / Pretty
  * pat guards
  * lambda case type annotation: \case : scrut -> ret
  * Parse Intrinsics (eg. getFnName , getSourceLine , getSourceFile etc..)
  * repl parser: multiline case / let
  * pretty case-case formats wrong
## Types
  * mode to print type-var bounds
  * Ad-hoc polymorphism: `Int <: [ NumInt Int ]` show (esp for repl JIT) (? mempty : Monoid a => a)
  * THFieldCollision
  * Dependent normalisation
  * first class polymorphism: eg. require instantiating with polytypes
    '<<' in let f : [a] -> [a] -> Int ; g : Bool -> [a] -> [a] in f << g
  * Linear types; dependent types required to quantify relative linearity `Lin t >= Lin f => t -> u`
## Beta-optimality:
  * λ Minimise normal forms: λ-encoding + lifting + sharing (if subterms of App or Match contain λ, lift them)
  * case-splitters as data for runtime optimisation
  * Partial applications extracted and specialised for beta optimality
  * Fns passed as args must have interpretable format
  * fns that do case-splits lazy in arguments they may not need
## Error messages
  * Warn nonsense type joins | infer a dependent type
  * conflicting definitions (from pattern args , let bindings etc..)
  * mixfix parser errors & locations
  * Literal is out of Int range
## Unimportant
  * optimise strbuf and literal string/arrays
  * rm (Core : Expr) in favor of tuple
  * Completion based on types (Type -> Bind)
  * tabs vs spaces
  * Need totality checker, else a Refl type may not terminate and thus proves nothing
  * strictly positive recursion
  * underdetermined recursion: https://counterexamples.org/underdetermined-recursion.html
    equirecursive => A = F[A] ; B = F[B] => A = B (unsound for arbitrary type-level functions F!)
    if multiple solutions for X = F X; eg. F X = X ; A = Int ; B = String
  * don't assume injectivity!
  * equality constraints are central to GADTs `Gabriel Scherer and Didier Rémy. GADTs meet subtyping.` `https://okmij.org/ftp/ML/first-class-modules/#GADT`
  * switch to codeberg
  * List comprehensions
  * cache version
  * Allow dynamic inspection of papped args
  * Pattern PTT: custom unPat function to support any patterns eg. `fact (<? 2) = 1`
  * error messages via prettyprinter Doc
  * language server
  * optimize cached modules
  * sh syntax `ls -lr +x` => `ls { l=False , r=False , x=True }` (Str2Label primitives?)
  * mergetyhead indicates if merge was a noop (so bisub knows it has already seen that input)
  * after function with no free-vars generalised, can trim but not fully clear bisubs!
  * Function = Constructor + rewrite rules ?
  * `typeOf : (t : Type) -> Type` shortcut to access (and alias) an inferred type
  * reinstate ArgProd f97cd9c0d01eddb562a029fa52ddee785e6a47b6
  * surround notes: cs"' cs'<q> cst" ds" ysiw] cs]{ yssb ds{ds) ysiw<em>
  * https://documentation.divio.com/
