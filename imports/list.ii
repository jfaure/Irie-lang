import imports/prelude

List A = data
  Nil
  Cons A (List A)
Str = List Char

length = foldr (\a b => b + 1) 0

--printList : List Int -> Int
printList l = case l of
  Nil => 0
  Cons i ll => add (putNumber i) (printList ll)

-- scansum: muroll & type intersection simplification
scanSum n l = ifThenElse (le n 0) l (scanSum (sub n 1) (Cons n l))

take n xs = if n <=? 0 then Nil else case xs of
  Nil => Nil
  Cons x xs => Cons x (take (n - 1) xs)

takeWhile p = \case
  Nil => Nil
  Cons x xs => if p x then Cons x (takeWhile p xs) else Nil

drop n xs = if n <=? 0 then xs else case xs of
  Nil => Nil
  Cons x xs => drop (n - 1) xs

fromMaybe l = case l of
  Maybe b => b
  Nothing => 0

null l = case l of
  Cons x xs => 0
  Nil       => 1

singleton x = Cons x Nil

repeat x = let xs = Cons x xs in xs

--span p xs = case xs of
--  Nil => { left = xs , right = xs }
--  Cons x xs2 => if p x
--    then let { left = ys , right = zs } = span p xs2 in (Cons x ys , zs)
--    else { left = Nil , right = xs }

foldr f s l = case l of
  Cons x xs => f x (foldr f s xs)
  Nil       => s

foldl f s l = case l of
  Cons x xs => foldl f (f s x) xs
  Nil => s

--unwords = \case
--  Nil => Nil
--  ws  => foldr1 (\w s => w ++ Cons ' ' s) ws

c a b = Cons a b
append front back = foldr c back front
_++_ = append
concat = foldr (append) Nil
-- n = Cons '\n' Nil
consF f x xs = Cons (f x) xs
mapFold f l = foldr (consF f) Nil l -- simple muroll test case
map = mapFold
concatMap f xs = foldr (\x b => foldr c b (f x)) Nil xs
--unlines ls = concat (mapFold (\l => append l (c '\n' Nil)) ls)
unlines = concatMap (\l => append l (Cons '\n' Nil))

unfoldr f b0 = case f b0 of
  Just ({ val as a , seed as b1 }) => Cons a (unfoldr f b1)
  Nothing       => Nil

filter pred l = case l of
  Nil => Nil
  Cons x xs => if pred x then Cons x (filter pred xs) else filter pred xs

-- String conversion
fromCString str = let
  go (ok , val , str2) = if ok then Cons val (go (nextElem str2)) else Nil
  in go (nextElem str)

toCString str = let
 unravel seed = case seed of
   Nil       => (0 , ? , ?)
   Cons x xs => (1 , x , xs)
 in unfoldArray unravel str

-- Int -> [a] -> ([a] , [a])
splitAt n xs = if n <=? 0 then { l = Nil , r = xs } else case xs of
  Cons x xs => let z = splitAt (n - 1) xs in { l = Cons x z.l , r = z.r }
  Nil => { l = Nil , r =  Nil }

reverse = foldl (\x xs => Cons xs x) Nil

-- mu-roll subtyping: [Cons {A , Âµd.[Nil | Cons {A , d}]}]
scanl f q ls = Cons q case ls of
  Nil => Nil
  Cons x xs => scanl f (f q x) xs

enumFromTo a b = ifThenElse (gt a b) Nil (Cons a (enumFromTo (add 1 a) b))

foldr1 f = \case
  Cons x xs => case xs of
    Nil => x
    Cons y ys => f x (foldr1 f xs)

nubBy eq l = let
  nub l xs = case l of
    Nil => Nil
    Cons y ys => if elemBy eq y xs then nub ys xs else Cons y (nub ys (Cons y xs))
  in nub l Nil

elemBy eq y = \case
  Nil => 1
  Cons x xs => boolOR (eq x y) (elemBy eq y xs)

{-
groupBy _ Nil = Nil
groupBy eq (Cons x xs) = let
  (ys , zs) = span (eq x) xs
  in Cons (Cons x ys) (groupBy eq zs)
-}

-- -- partition a list into sequence of intervals starting at the 1s in the boolean fretlist
--partition fretsList = case fretsList of
--  Nil => Nil
--  Cons x xs => if x.fret then Cons


-- go sep l = case l of
--   Nil => Nil
--   Cons x xs => Cons sep (Cons x xs)
--
-- intersperse sep l = case l of
--   Nil => Nil
--   Cons x xs => Cons x (go sep xs)
