# There is no satisfactory programming language today
# Intro; I want to give an objective overview of existing programming languages, with a particular focus on the shortcomings of every major option.
* Programs are becoming more complicated and more expensive to maintain. This may be a result of programmers becoming more focused on rapid developement with little respect for performance - the complete opposite of attitudes in the early days of computing where engineers did more with far less resources. (eg. chess ais less than 1Kb in size)

# Plan

# 2 common PL classifications: Imperative (Procedural & OO) and Declarative (Functional , Logic , Mathematical , Reactive) https://en.wikipedia.org/wiki/Programming_paradigm
languages can support multiple paradigms
* Imperative languages are inspired by physical machine architecture and revolve around instructing the CPU how to change its state. We can further distinguish between procedural languages (eg. C) and object oriented languages (C++)
* The Declarative paradigm involves writing the properties of the desired result, rather than focusing on how to physically compute it

## Imperative
* Now immediately you may be thinking "Well the declarative approach sounds more promising, since physical machine architecture is irrelevant to the actual problem I want to solve, and dealing with that will likely obfuscate code!". You are quite right. There are three complications however: First, its easy to understand why the first languages (especially C) so closely ressemble low level assembly - it was far easier to write a compiler for that, secondly, there is something intoxicating about having complete control over your processors' every move. Thirdly, having the compiler handle distracing details like memory and state is not trivial, with existing languages either doing so poorly, or shunting responsibility on to the programmer (and thus not solving the problem).
* Its time to introduce our first language, which at this point has reached legendary status: C. Most of the linux kernel, GNU and countless other programs are written in C, to name a few: Make, gcc, bash, most of gnu-utils, X, and even newer languages like Python and Ruby are all written in C. C has also been frequently used as a compilation target for other languages, including Haskell. Like any good IT student I started with and have written countless programs in C, from biginteger calculators, through a custom sed (a stream editor) to a raytracers and a 3d Rubik's cube.
* Of course C was just an initial stab in the dark developped alongside Unix, and quite quickly its limitations become apparent, in particular the complications associated with memory management and lack of any higher order concepts (Even sum types must be rewritten manually - you have to make a struct containing union and tag each time you want one) and so, apparently paradoxically, this extra control creates more rigid programs whose optimizations tend to degenerate with time as the program grows. From my experience, the only way for a C program to have a chance of remaining coherent is to have a dictator with a complete understanding of the codebase overseeing its developpement. This is the case with Linus Torvalds and Linux, and was the case until recently with Python.
* Frustrations among the Imperative paradigm's proponents with C's rigidity and forced attention to detail has triggered a number of reactions over the years, leading some to abuse the C preprocessor, others to develop C++, others to develop Python, or more recently Rust.
## With that, it is now time for our next major paradigm to enter the stage: Object oriented
* OO is well intentionned because it attempts to weaken the links between programs and assembly in an effort to allow programmers to focus on their actual problem. This is especially important because it lessens some of the rigidity forced on the user who must be excessively pedantic and encourages the separation of different program components. Unfortunately this isn't as big a step as one might have hoped, since OO as a model doesn't represent algorithms, but rather is a new and unnatural way to structure programs. I say unnatural because it arose as an improvement to other Imperative languages rather than as a well thought out solution to a problem that first of all would need to be well defined before we can try to solve it (More on that later). So really, it should come as no surprise that there are some weird issues with object oriented programming.
* There is even a direct substitution paradox: OO allows substitution based on subclasses, but semantically that only makes sense if the subclass is a subtype of the parent. Concretely, given an ellipse class, we can create a subclass for circles (where both axes are the same). Now a subclass must provide its superclasses methods, eg. stretchX. Unfortunately stretching a circle along one axis makes it into something that is no longer a circle - a contradiction. Some have suggested to reverse the subclass relation, but unfortunately ellipses fail to satisfy some invariants of the circle (like having a radius).
* Now having logical contradictions may not be fatal for a practical language, but it is extremely suspicious. These types of issues force the programmer to think extremely carefully about how he models his objects, especially where others will depend on his problematic class. In practice this can lead to a horrific soup of interdependencies and unsafe casts. This is a hacky imitation of subtyping.
* Penultimately, Python, which I like to describe as a C++ wrapper, in view of its major selling points being the easy interface to numerous fantastic scientific libraries it provides. The language itself appeared at a time when the main alternative was C, so the obviation of manual memory management made it an attractive proposition. Its lack of types also created a fun experiment for the time. It is otherwise a fairly typical imperative language, and despite being interpreted, it has managed to dodge some performance penalties by promoting the use of C/C++ libraries as opposed to interpreted loops.
* The final imperative language I want to mention is rust. I still recall the mad rush to rewrite rust's main libraries at a time when it was hyped up as being the future of programming. Certainly it offers many advantages over C, best of all memory safety, and finally, sum types! Native support for this datatype from the functional programming world is far more convenient than dealing with C-style tagged unions. Cargo, rust's package manager is also among the best. If only rust was around in the 80s, the software world would certainly be in a much better place. The thing is, as I've hinted at before, languages based on physical hardware architecture are fundamentally flawed: by their very nature they obfuscate programs and distract programmers with irrelevant details. This problem becomes exacerbated in multi-threaded environments, let alone distributed computing networks. The reason I focus so heavily on this point is because even small imperfections can have immense consequences on the flexibility of programs. It is sometimes said that programs are written once, modified 10 times and read 100 times. If this is even remotely true, then code flexibility and readability is of paramount importance, and we should not let anything obscure the algorithm we are trying to describe.

## Declarative
* So now we turn to declarative paradigms, where we no longer instruct the machine how to change it's state, but focus instead on declaring properties of our desired result. notably Functional, Mathematical and Logic. Given the numerous shortcomings of Imperative languages, why are declarative ones used even less often ? The biggest technical issue is that compilers for declarative languages are far more difficult to write, and until now, the potential has not been reached. Performance and trust in the compiler is especially important because the programmer's influence over the final machine code is greatly reduced compared to Imperative languages. Functional languages in particular are infamous for their lazy evaluation and garbage collectors, despite the compilers having relatively far greater information and guarantees about the code. They have so much more potential. Today Imperative languages have such a massive headstart that new programmers are understandably pointed to learning the likes of Python and javascript, because those are the most in demand.

* With what I felt was a necessary prelude out of the way, we can set our sights on the new world. Here I want to discuss 3 sub paradigms:
* Functional, where the result is declared as the value of a series of function applications (Haskell, Ocaml, J)
* Logic, where we put questions to a system of facts and rules (Prolog)
* Mathematical, where the result is the solution to an optimization problem (Wolfram , Mathematica , Octave)

# Mathematical and Logic paradigms are not designed for describing arbitrary algorithms but are worth a mention:
* The basic idea is to arm the compiler with a bunch of techniques for solving problems put to it, be it mathematical formulae or a constraint solver, so it is capable of solving a certain class of problems trivially. This type of automatic solver can possibly be implemented as a function for use by a more general language, but I mention them because they allow users to focus on their problem, and completely dodge thinking about and developping a solution. For problems the compiler can solve optimally, this is ideal.

# Brief interlude on typed languages
* A type is an annotation given to values or functions within a program whose purpose is to provide additional information about program entities and check that these are being used in a compatible way. The hardware also sometimes needs types since these tell it the size of variables (for example differentiate 32 and 64 bit numbers) Decades ago it may have seemed like a good idea to remove types in the surface language, since they seemed annoying and often a meaning could be deduced from weird usage in the language. Javascript is famously disastrous on this point. The unfortunate reality for untyped systems is that instead of increasing expressiveness, they have actually reduced it. Because every single value has no type, they have the same type. So what we end up with is a language with only a single type (which we now carefully avoid calling a type).

# Functional programming
* Finally, we look at the approach built upon a solid foundation of algorithmic descriptions and logical consistency. Pure functional programming even disallows side effects, so in addition to program safety, we can tell a lot just by looking at a function's type, and are far less likely to be surprised.
* Honorable mention in this category goes to Array oriented languages, in particular J, which I used exclusively for almost 4 months and had no small impact on my understanding of programming. The observation at the heart of Array languages is that the majority of looping constructs are in fact some sort of array operation, so we may as well embrace it. Arrays in J come with an associated dimension, which J calls their rank. Functions also have a base rank, which can be modified to direct execution to desired cells. Nowadays I use J as an extremely powerful calculator, and to this day I still think in terms of arrays as often as possible. The issue with J is that as soon as a problem is not cleanly representable in array terms, it becomes painful to use.
* Another honorable mention goes to languages based on the calculus of constructions, Coq, Agda and Idris to name a few. Types in these systems are as expressive as terms - which can guarantee program correctness and gives the potential for compiler optimisations, although that is yet to be seen.
* Besides Haskell, Ocaml presents a solid alternative as a practical programming language, however Haskell sticks closer to the spirit of pure functional programming, as well as currently being my main language, so it will be the focus.
* Haskell.. After over five years of study and of all the languages I've tried, this then is the one I consider currently best, although the extent of my compliments are that it is the best out of a bad choice. You see, Haskell's heart is in the right place, with pure functions at the centre of it, a solid community of researchers and as a well established general purpose language it has all the libraries you are likely to need.
* The issues with haskell are twofold: First the performance: compilation speeds are amazingly slow, and compiled code is not great, particularly in view of the extra information and guarantees programs receive from a pure functional style. These issues are surmountable if you know what you are doing, but even with enough experience, you often have to step away from the functional style to ensure your code is fast.
* Secondly, and far more seriously as far as I'm concerned, the language may as well be described as typeclass-oriented, considering how pervasive they are. Of the previous typed languages we've looked at, when more generic functions were desired, it was always possible to unsafely bitcast pointers or use inheritance. Now however, we need a theoretically sound way of doing this. Typeclasses amount to having a prolog-like language sitting atop Haskell, and end up being dragged through the entire compiler pipeline, making good optimizations almost hopeleses. They're nice enough to use as long as you have only one I suppose, with the Monad typeclass being the most famous one. Soon though you'll want more than one, when your main option becomes the monad transformer typeclasses, and this is where the concept becomes more and more suspicious. There is no synergy between typeclasses and Haskell, and all the concrete problems you get with them (like like non-extensionability, orphan-instances, coherence issues, lack of subtyping, implicit instantiation) are almost natural consequences of unnaturally layering another language on top of your base.

# Conclusion
* Hopefully this has been an accurate overview of the current most influential langugages, and the problems facing future language developpers. Now as stated Haskell is my default choice, with J and C seeing situtational use, but I wouldn't go so far as to recommend any single one. I will propose a solution to these issues in a future video, so subscribe if that sounds interesting !

This isn't so much a weakness of the language however. But because of this increased difficulty facing compiler engineers, at the dawn of programming languages when hardware was much weaker and less well understood, the only way forwards was for compiler engineers was to provide only a thin veil of convenience over the hardware and thus shift the burden of programming and performance on to the programmers. From that point onwards humans being creatures of habit and in general lacking the energy to question accepted practices simply continued along this path. After all, everything works so there is no pressure to change. Fast forwards to today, and
