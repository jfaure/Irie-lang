-- let-scope depends on parse
-- letscopeAfterMixfix y = if y then let x = 3 in x else y

--rect (P : Set) : Set = record
--Recangle = record
--  f : Int
--  g : Int
--import imports/prelude
--import imports/list
--import imports/list2
--import imports/cata
--import imports/question
--import imports/ls

--lol = \case
--  ? => 3

--x = let g = 3 in g
--y = let g = 3 in g
--x y = y <? y -- TODO warn duplicate bindings in same scope

-- letbinds must be solved in scope (freevars) , and their bind must also be reachable
--letGen2 a = let y = a in y
letGen3 x = let y z = x z in y  -- ∏ A B → (A → B) → A → B

-- = BruijnLam (BruijnAbsF {_nBound = 1, _bruijnMetas = [], _bruijnNest = 0,
--  _bruijnBody = App (BruijnLam (BruijnAbsF {_nBound = 1, _bruijnMetas = [], _bruijnNest = 1
--  , _bruijnBody = Var (VQBind (QName 2147483649))}))
--  [BruijnLam (BruijnAbsF {_nBound = 1, _bruijnMetas = [], _bruijnNest = 1
--    , _bruijnBody = App (Var (VBruijn 1)) [Var (VBruijn 0)]})]})})

--f = \(a , b) => a + a

{-
fmap f = \case
  Done      ⇒ Done
--Skip r    ⇒ Skip r
  Yield x r ⇒ Yield x (f r)

rcata f = f << fmap (rcata f)
rana g = fmap (rana g) << g
rhylo f g = f << fmap (rhylo f g) << g

-- ∀s. stream (unstream s) ⇒ s
Sfuse next (stream n0 s0) = stream (next << n0) s0
Sana  (stream n s) = rana  n s
Scata (stream n s) = rcata n s

ana next seed = @stream next seed
cata c (stream a seed) = rhylo c a seed

map f = Sfuse \case
  Done      ⇒ Done
  Yield x r ⇒ Yield (f x) r

enumFromTo lo hi = ana (\i ⇒ if i >? hi then Done else Yield i (i + 1)) lo

sum = cata \case
  Done      ⇒ 0
  Yield x r ⇒ x + r

--l = sum (enumFromTo 5 10)
r = sum (map (add 1) (enumFromTo 5 10))
-}

-- f n = sum [ k * m | k ← [1..n] , m ← [1..k] ]
-- T[E | ] = return E
-- T[E | B , Q] = guard B T[E | Q]
-- T[E | P ← L , Q] = let f P = True ; f _ = False
--                        g P = T[E | Q]
--                    in concatMap (\x ⇒ guard (f x) (g x)) L
-- T[E | let decls , Q] = let decls in T [E | Q]

--merge all co-occurs of recursive var into the μ-binder
--foldr1 f l = case l of
--  Cons x xs ⇒ case xs of
--    Nil ⇒ x
--    Cons y ys ⇒ f x (foldr1 f xs)

{-
ifThenElseL cond a b = case cond of
  True  ⇒ a
  False ⇒ b

-- sumAppend n = sum [m * m | m ← [1..n]]
-- = foldl _+_ 0 (concatMap (\m ⇒ pure (m * m)) (enum 1 n)
nextEnum n = case n >=? 10 of
  True  ⇒ @Done
  False ⇒ @Yield n (1 + n)

nextConcatMap i nest = case nest of
  J (Stream next s0) ⇒ case next s0 of
    Done      ⇒ @Skip i @N
    Skip s    ⇒ @Skip i (J (Stream next s))
    Yield y s ⇒ @Yield y i (J (Stream next s))
  N ⇒ case nextEnum i of
    Done   ⇒ Done
    Skip i ⇒ Skip i N
    Yield x i ⇒ let
      nextRet x = \case
        True  ⇒ Yield (x * x) False
        False ⇒ Done
      in Skip i (J (Stream (nextRet x) True))

go z s0 s1 = case nextConcatMap s0 s1 of
  Done        ⇒ z
  Skip s q    ⇒ go z s q
  Yield x s q ⇒ go (z + x) s q

sumAppend n = go 0 n N
-}
