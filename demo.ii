--leftFold ∷ [Int] → Int → In
--leftFold = cata $ \d acc → case d of
--  Nil → acc
--  F.Cons x xs → if x > 100 then acc else xs acc + x

-- math2 = 1 + 2 * 3 + 4 -- should be: (1 + (2 * 3)) + 4
-- let-scope depends on parse
-- letscopeAfterMixfix y = if y then let x = 3 in x else y

--rect (P : Set) : Set = record
--Recangle = record
--  f : Int
--  g : Int
import imports/prelude
--import imports/list
--import imports/list2

--import imports/cata
--import imports/question
--import imports/ls

-- File CString ; Dir CString (List Dir)
--printDirTree : Str -> Dir -> Str
-- !??
--printDirTree prefix = \case
--  File f  ⇒ prefix ++ f
--  Dir d r ⇒ prefix ++ d ++ concatMap (printDirTree (fromCString " |-- " ++ prefix)) r

--x = let g = 3 in g
--y = let g = 3 in g

{-
fmap f = \case
  Done      ⇒ Done
--Skip r    ⇒ Skip r
  Yield x r ⇒ Yield x (f r)

rcata f = f << fmap (rcata f)
rana g = fmap (rana g) << g
rhylo f g = f << fmap (rhylo f g) << g

-- ∀s. stream (unstream s) ⇒ s
Sfuse next (stream n0 s0) = stream (next << n0) s0
Sana  (stream n s) = rana  n s
Scata (stream n s) = rcata n s

ana next seed = @stream next seed
cata c (stream a seed) = rhylo c a seed

map f = Sfuse \case
  Done      ⇒ Done
  Yield x r ⇒ Yield (f x) r

enumFromTo lo hi = ana (\i ⇒ if i >? hi then Done else Yield i (i + 1)) lo

sum = cata \case
  Done      ⇒ 0
  Yield x r ⇒ x + r

--l = sum (enumFromTo 5 10)
r = sum (map (add 1) (enumFromTo 5 10))
-}

-- f n = sum [ k * m | k ← [1..n] , m ← [1..k] ]
-- T[E | ] = return E
-- T[E | B , Q] = guard B T[E | Q]
-- T[E | P ← L , Q] = let f P = True ; f _ = False
--                        g P = T[E | Q]
--                    in concatMap (\x ⇒ guard (f x) (g x)) L
-- T[E | let decls , Q] = let decls in T [E | Q]

--merge all co-occurs of recursive var into the μ-binder
--foldr1 f l = case l of
--  Cons x xs ⇒ case xs of
--    Nil ⇒ x
--    Cons y ys ⇒ f x (foldr1 f xs)

{-
fromMaybe x = case x of
  Nothing ⇒ 0
  Just a  ⇒ a

-- sumAppend n = sum [m * m | m ← [1..n]]
-- = foldl _+_ 0 (concatMap (\m ⇒ pure (m * m)) (enum 1 n)
bool2Bool i = ifThenElse i @true @false
nextEnum n = case bool2Bool (ge n 10) of
  true  ⇒ @Done
  false ⇒ @Yield n (add 1 n)

nextConcatMap i nest = case nest of
  Just (Stream next s0) ⇒ case next s0 of
    Done      ⇒ @Skip i Nothing
    Skip s    ⇒ @Skip i (Just (Stream next s))
    Yield y s ⇒ @Yield y i (Just (Stream next s))
  Nothing ⇒ case nextEnum i of
    Done   ⇒ Done
    Skip i ⇒ Skip i Nothing
    Yield x i ⇒ let
      nextRet x = \case
        true  ⇒ Yield (mul x x) false
        false ⇒ Done
      in Skip i (Just (Stream (nextRet x) true))

go z s0 s1 = case nextConcatMap s0 s1 of
  Done        ⇒ z
  Skip s q    ⇒ go z s q
  Yield x s q ⇒ go (add z x) s q

sumAppend n = go 0 n Nothing
-- expect z i = if i >? n then z else expect (z + i ∗ i) (i + 1)
-}

bool2N = \case
  True  => 1
  False => 0

g2 z i (Wrap next) s = case next s of
  Done      => g1 z i
  Yield x s => g2 (z + x) i (Wrap next) s

g1 z i = let
  nextRet x = case x of
    True  => Yield (i * i) False
    False => Done
  in if i >? 10 then z else g2 z (i + 1) (Wrap nextRet) True
