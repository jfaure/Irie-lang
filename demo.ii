-- let-bound mixfix
-- poly1 = let _<_ = \f a => f a in (\y => y.t) < { t = 1 }  -- %i1

-- bad type depending on order of mutuals
--ii/SpecialisationTests/WrappedSimpleMutual.ii"

-- Let conflict "0"
--eq1 @x b = 2
--eq1 a b = 3

-- ∃ type in optparse-applicative
-- data Parser a
--   = NilP (Maybe a)
--   | OptP (Option a)
--   | forall x . MultP (Parser (x -> a)) (Parser x)

--imports list list2 tree question ls foldr Free parsec intmap patternTests hash
--import irieShell -- ideas for irie as shell
--import imports/TreeStream
--import SpecialisationTests/{SpecPapArg , SimpleMutual , SumOfSquares , fib , WrappedSimpleMutual}
--import SpecTests
--import testBruijns -- β-reduction
--import testFuse
--import sumMul
--import letCaptureTests
--import casecase
--import tupleTests
--import mutumorphism -- avoid let-block
--import Tee -- duplicate streams

-- multi-branch μ merge =>
-- rec1 v = { a = rec1 v , b = rec1 v }  -- ∏ A B → ⊤ → µa.{a : a , b : a}

-- Libs: Optparse Lens List Eff DFA BitSet

-- Cat records: V and ^

-- pdep captures

-- Resolve type aliases
--Rectangle = { f = Int , g = Int }
--r : Rectangle
--r = \x y => { f = 3 , g = 10 }
--type params (conv fn to THBi or embed Core in types)
--Maybe a = data
--  Nothing
--  Just a

--import ii/FA/CharScan/MiniPrefix
import stream
f = enumFromTo -- 0 10 -- 0 .. 10
g (stream next i) = next i

-- vv promoting inames to topNames breaks popcount lookup
--import odd
--f = gg
