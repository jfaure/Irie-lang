--rec1 v = { a = rec1 v , b = rec1 v }  -- ⊤ → µx.{a : x , b : x}

--testParity n = let
--  isEven n = ifThenElse (eq n 0) 1 (isOdd (sub n 1))
--  isOdd n  = ifThenElse (eq n 0) 0 (isEven (sub n 1))
--  in isEven n

--rect (P : Set) : Set = record
--  f : Int
--  g : Int
import imports/prelude
import imports/list
--import imports/question
--import imports/ls
import imports/parser

{-
-- File CString ; Dir CString (List Dir)
--printDirTree : Str -> Dir -> Str
printDirTree prefix = \case
  File f   => prefix ++ f
  Dir d r => prefix ++ d ++ concatMap (printDirTree (fromCString " |-- " ++ prefix)) r
-}

{-
-- µc.[Cons {A , µc.[Nil]}] => µc.[Nil | Cons {A , c}]
-- ? roll into mutype: [Nil | Cons {[Cons {A , [Nil]}]
-- [a] -> [[a]]
nonEmptySubSequences = \case
  Nil => Nil
  Cons x xs => let
    f ys r = Cons ys (Cons (Cons x ys) r)
    in Cons (Cons x Nil) (foldr f Nil (nonEmptySubSequences xs))
-}

--ParseState = record
--  state  : { input : Stream , offset : Int }
--  cok : a          -> ParseState -> m b
--  cko : ParseError -> ParseState -> m b
--  eok : a          -> ParseState -> m b
--  eko : ParseError -> ParseState -> m b
-- ErrorItem t = Tokens (NonEmpty t) | Label (NonEmpty Char) | EndOfInput

{-
pure x ps = (ps . ret . set x) . cok . set 1
--pure x ps = ps . { ret = x , status = @cok }

pTakeP n = \s cok _ _ eko => let
  split = splitAt n s.input
  in if length split.l /=? n then eko "Bad length" else cok split.l (s.input.set (split.r))
-}

n @N = 0
take n xs = if n <=? 0 then N else case xs of
  N => N
  C x xs => C x (take (n - 1) xs)

mergeRec = \case
  N => { x = 1 }
  C => { y = 1 }

--
--lp17 f = let r x g = { a = g x , b = f x } in {u = r 0 (add 1) , v = r {t = 1} (\y => y.t)}
--
--pTakeWhileP f = \s cok _ eok _ => let
--  split = span f f s.input
--  in if null split.l
--    then eok split.l s
--    else cok split.l (s.input.set split.r)

--pToken

--span p xs = case xs of
--  Nil => { left = xs , right = xs }
--  Cons x xs2 => if p x then let { left = ys , right = zs } = span p xs2 in (Cons x ys , zs) else { left = Nil , right = xs }
--
