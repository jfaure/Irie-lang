--rec1 v = { a = rec1 v , b = rec1 v }  -- ⊤ → µx.{a : x , b : x}

--testParity n = let
--  isEven n = ifThenElse (eq n 0) 1 (isOdd (sub n 1))
--  isOdd n  = ifThenElse (eq n 0) 0 (isEven (sub n 1))
--  in isEven n

--rect (P : Set) : Set = record
--  f : Int
--  g : Int

--intersectBy          :: (a -> a -> Bool) -> [a] -> [a] -> [a]
--intersectBy _  [] _  =  []
--intersectBy _  _  [] =  []
--intersectBy eq xs ys =  [x | x <- xs, any (eq x) ys]

--intersperse             :: a -> [a] -> [a]
--intersperse _   []      = []
--intersperse sep (x:xs)  = x : prependToAll sep xs

--prependToAll            :: a -> [a] -> [a]
--prependToAll _   []     = []
--prependToAll sep (x:xs) = sep : x : prependToAll sep xs

-- wordsBy linesBy
-- unionBy
-- transpose permuatations
-- mapAccumL(R)
-- insertBy
-- sortBy
-- zip
-- find findIndex findIndices
-- partition
-- isInfixOf isSuffixOf isPrefixOf
-- span break
-- split splitOn chunksOf
-- compareLength : [a] -> Int -> Ordering
--   = foldr (\_ acc n -> if n > 0 then acc (n - 1) else GT) (compare 0)
-- dropWhileEnd : (a -> Bool) -> [a] -> [a]
--   = \p -> foldr (\x xs -> if p x && null xs then [] else x : xs) []
import imports/prelude
import imports/list
--import imports/ls

{-
-- File CString ; Dir CString (List Dir)
--printDirTree : Str -> Dir -> Str
printDirTree prefix = \case
  File f   => prefix ++ f
  Dir d r => prefix ++ d ++ concatMap (printDirTree (fromCString " |-- " ++ prefix)) r
-}

{-
-- µc.[Cons {A , µc.[Nil]}] => µc.[Nil | Cons {A , c}]
-- ? roll into mutype: [Nil | Cons {[Cons {A , [Nil]}]
-- [a] -> [[a]]
nonEmptySubSequences = \case
  Nil => Nil
  Cons x xs => let
    f ys r = Cons ys (Cons (Cons x ys) r)
    in Cons (Cons x Nil) (foldr f Nil (nonEmptySubSequences xs))
-}

--null = \case
--  C => C
--  N => N
--
---- splitAt :: Int -> [a] -> ([a], [a])
--splitAt n xs = if n <=? 0 then { l = N , r = xs } else case xs of
--  C x xs => let z = splitAt (n - 1) xs in { l = C x z.l , r = z.r }
--  N => { l = N , r =  N }

r1 = { x = 3 , y = x }

--testParity n = let
--  isEven n = ifThenElse (eq n 0) 1 (isOdd (sub n 1))
--  isOdd n  = ifThenElse (eq n 0) 0 (isEven (sub n 1))
--  in isEven n
