-- let-scope depends on parse
-- letscopeAfterMixfix y = if y then let x = 3 in x else y

-- pattern assignments; ? make mutual λ over whole record
-- (f , g) = (2 , 3)

-- let-bound mixfix => make VLetBind instead of QName
-- poly1 = let _<_ = \f a => f a in (\y => y.t) < { t = 1 }  -- %i1

--rect (P : Set) : Set = record
--Recangle = record
--  f : Int
--  g : Int

--import prelude
--import list
--import list2
--import tree
--import question
--import ls
--import foldr
--import question
--import Free
--import parsec
--import intmap

--import stream
--import imports/TreeStream

-- parse pattern guards
--f = \case { @x b | @y <- b => 1 }

-- Merge equations properly, this creates 2 bindings and bugs out inames
-- Also disallow extra names between the equations (scoped fields?)
--eq1 (@x) b = 2
--eq1 a b = 3

-- index out of bounds
-- g (x a) = a -- no '@', so x uses bind-name not label name

-- Label namespaces + label application
--f x = label x x -- check if label in scope as label ? or requrie @
--f (x a) = a
--g = \case
--  x => x -- Always label

--import prelude
--x = True -- Ambiguous binding (@True OK)

-- Re-generalise let-binds + Add free-variables into type to codegen let-binds

-- tvars must never refer to deeper let-nest tvars through their bounds
-- need to save state tvars => only biunify with instantations not the escaped tvar
-- perhaps should explicitly pass down args straight after scope-check to avoid the annoyance
--lp17 f = let r x g = { a = g x , b = f x } in { u = r 0 (add 1) , v = r {t = 1} (\y => y.t)}
-- ∏ A → ((%i1 ⊔ {t : %i1}) → A) → {u : {a : %i32 , b : A} , v : {a : %i1 , b : A}}

-- lost some μ-bounds
-- import foldr
-- nonEmptySubSequences = \case -- [a] -> [[a]]
--   @Nil       => Nil
--   @Cons x xs => let
--     f ys r = Cons ys (Cons (Cons x ys) r)
--     in Cons (Cons x Nil) (foldr f Nil (nonEmptySubSequences xs))

--list2.unwords = merge μ-bounds upwards even if layer not equal

-- multi-branch different μ merging =>
-- rec1 v = { a = rec1 v , b = rec1 v }  -- ∏ A B → ⊤ → µa.{a : a , b : a}

-- Wildcard (poison cannot merge cases)
--null = \case
--  @None => @True
--  ? => @False

-- parse indented nested lets
--f x =
-- let g y =
--   let h z = add z (add x y) in h
-- in g

-- ! returning let-bind outside its scope messes up its name resolution

--import SpecialisationTests/SpecPapArg
--import SpecTests
--import SpecialisationTests/SimpleMutual
--import SpecialisationTests/SumOfSquares
--import SpecialisationTests/fib
--import list
--import testBruijns -- β-reduction
--import testFuse
--import sumMul
--import stream
--import prelude

--import letCaptureTests
--import list

--import casecase
--import tupleTests
--import stream

-- Tee: shared pointer to cached stream: usage: tee str > \(strL , strR) => ..
-- ! Vec is a builtin that reallocs itself if push exceeds its bounds
-- Vec = { size : Int , ptr : Mem }
-- TODO multi-ref: teeN function
-- TODO ERA: how to free if stream copy is unused
--tee (@stream inNext s0) = VecNew > \ptr => let
--  next (s , n) = case n >= ptr.cached of
--    True  => Yield (VecRead ptr n) (n + 1)
--    False => inNext s > \x => VecPush ptr n x (Yield x (n + 1)) -- ! writePtr
--  in @stream next s0

{-
import prelude
--scanSum n l = if n <? 0 then l else scanSum (sub n 1) (Cons n l)
splitAt n xs = if n <=? 0 then { l = @Nil , r = xs } else case xs of
-- KO , inlining '>' messes up free-Vars for the ( , ) LetBlock
  @Cons x xs => splitAt (n - 1) xs > \R => ( { l = @Cons x R.l , r = R.r } )
-- OK
--  @Cons x xs => (\(l , r) => ( @Cons x l , r )) (splitAt (n - 1) xs)
  @Nil =>  { l = @Nil , r = @Nil }

--t0 = (scanSum 1 Nil)
t1 = splitAt 1 (Cons 0 Nil) -- ([0] , [1])
--t2 = splitAt 1 (scanSum 2 Nil)
-}

--import stream
import SpecialisationTests/WrappedSimpleMutual

{-
import prelude

Sappend (@stream nextL sl0) (@stream nextR sr0) = let
  next = \case
    @Left  sa => case nextL sa of
      @Done      => Skip    (Right sr0)
      @Skip s    => Skip    (Left s)
      @Yield x s => Yield x (Left s)
    @Right sb => case nextR sb of
      @Done      => Done
      @Skip s    => Skip    (Right s)
      @Yield x s => Yield x (Right s)
  in ana next (@Left sl0)

SconcatMap f (@stream nexta seed) = let
  nextC S = case S.m of
    @None => case nexta S.sa of
      @Done      => Done
      @Skip s    => Skip { sa = s , m = @None}
      @Yield a s => Skip { sa = s , m = @One (f a)}
    @One (@stream nextb sb) => case nextb sb of
      @Done      => Skip    {sa = S.sa , m = @None}
      @Skip s    => Skip    {sa = S.sa , m = @One (stream nextb s)}
      @Yield b s => Yield b {sa = S.sa , m = @One (stream nextb s)}
  in @stream nextC {sa = seed , m = None}

ana next seed = @stream next seed

enumFromTo lo hi = ana (\i => if i >? hi then @Done else @Yield i (i + 1)) lo
empty = @stream (\x => x) @Done

foldr c z (@stream next seed) = let -- rhylo c a seed
  go s = case next s of
    @Done      => z
    @Skip r    => go r
    @Yield x r => c x (go r)
  in go seed

t   = foldr add 0 (enumFromTo 0 10)
tt  = foldr add 0 (Sappend (enumFromTo 0 1) (enumFromTo 1 2))
ttt = foldr add 0 (SconcatMap (enumFromTo 10) (enumFromTo 5 10))

-}
