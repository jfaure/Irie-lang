-- let-bound mixfix in scope outside, wrong IName/Letname
-- poly1 = let _<_ = \f a => f a in (\y => y . t) < { t = 1 }  -- %i1

-- Illegal pattern
-- eq1 @x b = 2
-- eq1 a b = 3

-- recursive Tree Automata; enumerate data modulo (N constructors) and build a NFA transition table

-- reduced form: {l1 : α} v {l1 : β, l2 : β} v µγ.α → γ
-- => {l1 : α v β} v α -> (µγ.α -> γ) -- At most 1 type from each component
-- Subsumption: [Δ1]τ1 <=? [Δ2]τ2 => [Δ2]τ2 =? [Δ1^Δ2]τ1vτ2
-- Type = record
--   theads : Vector THead -- add dodgy alt THeads=[THead]
--   δ      : Vector (NonEmpty Int) -- states index theads

-- Allow less general annotations
-- f : Int -> { f0 = Int }
-- f x = { f0 = x }

-- Topo-sort modules so dependents always computed first (esp. for asm offsets)

--imports list list2 tree question ls foldr Free parsec intmap patternTests hash
--import irieShell -- ideas for irie as shell
--import imports/TreeStream
--import SpecialisationTests/{SpecPapArg , SimpleMutual , SumOfSquares , fib , WrappedSimpleMutual}
--import SpecTests
--import testBruijns -- β-reduction
--import testFuse
--import sumMul
--import letCaptureTests
--import casecase
--import tupleTests
--import Tee -- duplicate streams
--import dir

-- Cat records: V and ^
-- set/get formal semantics, add new fields?
-- Presence variables

-- multi-branch μ merge =>
-- rec1 v = { a = rec1 v , b = rec1 v }  -- ∏ A B → ⊤ → µa.{a : a , b : a}

-- Libs: Optparse Lens List Eff DFA BitSet

-- Profunctor Lenses: lens|prims|iso|adapter|traversal|getter|fold
-- * Set unconditionally adds a field (scoped-fields can stack)
-- * Optic = p a b -> p s t
-- * Lens = view : s -> a , update : (b , s) -> t
-- ? GLens : (s -> (a -> b) -> (b , t)) => view s = fst (glens s identity) ; update s x = snd (glens s (const x))
-- 'x' field QName not imported.
-- import Maybe?
-- f = rect . x

-- type params (conv fn to THBi or embed Core in types)
-- type application vs implicit THBi
-- Maybe a = data
--   Nothing
--   Just a

-- Sort out import label scopes, incl '@' version
-- ! JudgedModule.openDatas is the key
--import Maybe
--Maybe = data
--  Just Int
--f = Just 3

-- Allow recursive data types; μ?
--IntList = data
--  Nil
--  Cons Int -- IntList
--g (Cons x) = x
--f = Cons 3

--import Maybe

--ifThenElse cond a b = case lt cond 0 of
--  True  => add 0 a
--  False => add 0 b

-- unfold to stack : (s -> Maybe (Char , s)) -> s -> ((Nat , CString) -> a) -> a
-- import prelude
-- -- Int -> Maybe (Char , Int)
-- nextDigitU n = divMod n 10 > \(q , r) => if q =? 0 && r =? 0 then Void else Just (chr (48 + r) , q)
-- itoa n = withUnfoldL nextDigitU n (\len str => putsN str len)

-- ! retLocs must be respected. arg locs may be reassigned (mov Vs push, overwrite v call)
-- ?? args <=> regs. (args have dup info , regs are direct currency of asm)
-- ? flip commutative operations iff right reg needed as dest
-- eg. bruijnArg RDI -> dup RDI => x RDI (RDI maybe destroyed)
--  -> ccalling conv RDI -> recover x
--   RetLoc
--  /  op  \ One branch should use retloc. Regs may be dup / calling convs involved
-- ? fst branch gets priority
-- flexible: push , dup , forks
fac n = case lt n 2 of
  True  => n
  False => mul n (fac (sub n 1))

main i = fac i

--dup x = add x x

--pap = add 3

--algebra x y z = add 5 (add x (mul (sub y 2) z))

--plus1 x y = add x y
--plus2 (x , y) = add x y

--main = 3
