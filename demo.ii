-- let-bound mixfix in scope outside, wrong IName/Letname
-- poly1 = let _<_ = \f a => f a in (\y => y . t) < { t = 1 }  -- %i1

-- Index out of bounds on use before declare
-- x = Just 3
--Maybe = data
--  Just Int
--f = Just 3 -- ok

-- IName > mName binds (somehow mismatched QName/IName pairs)
--import ii/m1
--g = m1f
--z = _<_

-- Illegal pattern (multi equation)
-- eq1 @x b = 2
-- eq1 a b = 3

-- recursive Tree data Automata; enumerate data modulo N (constructors) and build a NFA transition table. Spawn list for each constructor

-- Topo-sort modules so dependents always computed first (esp. for asm offsets)

--imports list list2 tree question ls foldr Free parsec intmap patternTests hash
--import irieShell -- ideas for irie as shell
--import imports/TreeStream
--import SpecialisationTests/{SpecPapArg , SimpleMutual , SumOfSquares , fib , WrappedSimpleMutual}
--import SpecTests
--import testBruijns -- β-reduction
--import testFuse
--import sumMul
--import letCaptureTests
--import casecase
--import tupleTests
--import Tee -- duplicate streams
--import dir
--import asmTests
--import ii/Subsumption

-- multi-branch μ merge =>
-- rec1 v = { a = rec1 v , b = rec1 v }  -- ∏ A B → ⊤ → µa.{a : a , b : a}

-- Qualified modules, name clash? (eg. Maybe.Maybe)
-- import Maybe
-- y = Maybe

-- Allow declare recursive data types; μ?
--IntList = data
--  Nil
--  Cons Int -- IntList
--g (Cons x) = x
--f = Cons 3


-- type params (conv BruijnAbs to THBi)
-- * Bruijns in types are already THBounds
-- ? type application vs implicit
-- Maybe a = data
--   Nothing
--   Just a
-- f = Just 3

-- record wildcard
-- { x = Int , y } -- indicates y = ?

-- Need to Subtype case outputs to largest type
-- fac => cannot codegen type: (%i1 ⊔ %i32)

-- β-env loops
fac n = case le n 1 of
  True => 257
  False => mul n (fac (sub n 1))
main x = fac x

-- TODO emitC: passdown env
