--leftFold ∷ [Int] → Int → In
--leftFold = cata $ \d acc → case d of
--  Nil → acc
--  F.Cons x xs → if x > 100 then acc else xs acc + x

-- math2 = 1 + 2 * 3 + 4 -- should be: (1 + (2 * 3)) + 4
-- let-scope depends on parse
-- letscopeAfterMixfix y = if y then let x = 3 in x else y

--rect (P : Set) : Set = record
--Recangle = record
--  f : Int
--  g : Int
import imports/prelude
--import imports/list
--import imports/list2

--import imports/cata
--import imports/question
--import imports/ls

-- File CString ; Dir CString (List Dir)
--printDirTree : Str -> Dir -> Str
-- !??
--printDirTree prefix = \case
--  File f  ⇒ prefix ++ f
--  Dir d r ⇒ prefix ++ d ++ concatMap (printDirTree (fromCString " |-- " ++ prefix)) r

--x = let g = 3 in g
--y = let g = 3 in g

{-
fmap f = \case
  Done      ⇒ Done
--Skip r    ⇒ Skip r
  Yield x r ⇒ Yield x (f r)

rcata f = f << fmap (rcata f)
rana g = fmap (rana g) << g
rhylo f g = f << fmap (rhylo f g) << g

-- ∀s. stream (unstream s) ⇒ s
Sfuse next (stream n0 s0) = stream (next << n0) s0
Sana  (stream n s) = rana  n s
Scata (stream n s) = rcata n s

ana next seed = @stream next seed
cata c (stream a seed) = rhylo c a seed

map f = Sfuse \case
  Done      ⇒ Done
  Yield x r ⇒ Yield (f x) r

enumFromTo lo hi = ana (\i ⇒ if i >? hi then Done else Yield i (i + 1)) lo

sum = cata \case
  Done      ⇒ 0
  Yield x r ⇒ x + r

--l = sum (enumFromTo 5 10)
r = sum (map (add 1) (enumFromTo 5 10))
-}

bool2N = \case
  True  ⇒ 1
  False ⇒ 0

-- go2 scruts (next s) ⇒ indicate structure needs both args
go2 z i next s = case next s of
  Done      ⇒ go1 z i
  Yield x s ⇒ go2 (add z x) i next s

go1 z i = let
  nextRet x = case x of
    True  ⇒ Yield (mul i i) False
    False ⇒ Done
  in ifThenElse (ge i 10) z (go2 z (add i 1) nextRet True)

rr = {}
