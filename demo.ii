-- let-scope depends on parse
-- letscopeAfterMixfix y = if y then let x = 3 in x else y

-- ? make top-level lambda over entire module to resolve patterns
-- (f , g) = (2 , 3)

--rect (P : Set) : Set = record
--Recangle = record
--  f : Int
--  g : Int
--import imports/prelude
--import imports/list
--import imports/list2
--import imports/cata -- Recursion schemes
--import imports/question
--import imports/ls

--f = \case { @x b | @y <- b => 1 }

-- Merge equations properly, this creates 2 bindings and bugs out inames
--eq1 (@x) b = 2
--eq1 a b = 3

-- let-bound mixfix => make VLetBind instead of QName
-- poly1 = let _<_ = \f a => f a in (\y => y.t) < { t = 1 }  -- %i1

-- Re-generalise let-binds + Add free-variables into type to codegen let-binds

-- Label namespaces + label application
--f x = label x x -- check if label in scope as label ? or requrie @
--f (x a) = a
--g = \case
--  x => x -- Always label
-- v  (prelude + demo.ii.True)
-- import imports/prelude
-- x = True -- Ambiguous binding (@True OK)

-- f (x a) = a -- x uses bind-name not label name

-- tvars must never refer to deeper let-nest tvars through their bounds
-- need to save state tvars => only biunify with instantations not the escaped tvar
-- lp17 f = let r x g = { a = g x , b = f x } in { u = r 0 (add 1) , v = r {t = 1} (\y => y.t)}
-- ∏ A → ((%i1 ⊔ {t : %i1}) → A) → {u : {a : %i32 , b : A} , v : {a : %i1 , b : A}}

-- Need to accurately delegate generalisation to first mutual
-- import imports/sumMul

-- lost some μ-bounds
-- import imports/foldr
-- nonEmptySubSequences = \case -- [a] -> [[a]]
--   @Nil       => Nil
--   @Cons x xs => let
--     f ys r = Cons ys (Cons (Cons x ys) r)
--     in Cons (Cons x Nil) (foldr f Nil (nonEmptySubSequences xs))

--list2.unwords = merge μ-bounds upwards even if layer not equal

-- multi-branch different μ merging =>
--rec1 v = { a = rec1 v , b = rec1 v }  -- ∏ A B → ⊤ → µa.{a : a , b : a}

-- register occurs buggy
-- import imports/intmap

-- Wildcard
--null = \case
--  @None => @True
--  ? => @False
-- import imports/intmap

--import imports/question

{-
import imports/prelude
-- Fusion
-- sumAppend n = sum [m * m | m <- [1..n]]
-- = foldl _+_ 0 (concatMap (\m => pure (m * m)) (enum 1 n)
nextEnum n = case n >=? 10 of
  @True  => @Done
  @False => @Yield n (1 + n)

nextConcatMap i nest = case nest of
  @J (@Stream next s0) => case next s0 of
    @Done      => @Skip i @N
    @Skip s    => @Skip i (J (Stream next s))
    @Yield y s => @Yield y i (J (Stream next s))
  @N => case nextEnum i of
    Done   => Done
    Skip i => Skip i N
    Yield x i => let
      nextRet x = \case
        @True  => Yield (x * x) False
        @False => Done
      in Skip i (J (Stream (nextRet x) True))

go z s0 s1 = case nextConcatMap s0 s1 of
  @Done        => z
  @Skip s q    => go z s q
  @Yield x s q => go (z + x) s q

sumAppend n = go 0 n N
-}
