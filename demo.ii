-- let-bound mixfix in scope outside, wrong IName/Letname
-- poly1 = let _<_ = \f a => f a in (\y => y . t) < { t = 1 }  -- %i1

-- Index out of bounds on use before declare
-- x = Just 3
--Maybe = data
--  Just Int
--f = Just 3 -- ok

-- Illegal pattern (multi equation)
-- eq1 @x b = 2
-- eq1 a b = 3

-- record wildcard
-- { x = Int , y } -- indicates y = ?

--imports list list2 tree question ls foldr Free parsec intmap patternTests hash
--import irieShell -- ideas for irie as shell
--import imports/TreeStream
--import SpecialisationTests/{SpecPapArg , SimpleMutual , SumOfSquares , fib , WrappedSimpleMutual}
--import SpecTests
--import testBruijns -- β-reduction
--import testFuse
--import sumMul
--import letCaptureTests
--import casecase
--import tupleTests
--import Tee -- duplicate streams
--import dir
--import asmTests
--import ii/Subsumption
--import CTests

-- multi-branch μ merge =>
-- rec1 v = { a = rec1 v , b = rec1 v }  -- ∏ A B → ⊤ → µa.{a : a , b : a}

-- Qualified modules, name clash? (eg. Maybe.Maybe)
-- import Maybe
-- y = Maybe

-- Allow declare recursive data types; μ?
--IntList = data
--  Nil
--  Cons Int -- IntList
--g (Cons x) = x
--f = Cons 3

-- type params (conv BruijnAbs to THBi)
-- * Bruijns in types are already THBounds
-- ? type application vs implicit
-- Maybe a = data
--   Nothing
--   Just a
-- f = Just 3

-- Topo-sort / declare / dep graph
-- ! Unfold(constructLN) inferrence, mutate perm table
-- main = f 3 2
-- f x y = add x y

-- Polymorphism, esp. ∀a. a ⊓ T -> a
-- ! BasicTypeBound : [Tlo <: a <: Thi] => a -> a
-- typedef all tvars

-- η-expand paps
--t = add

-- withAlloca : ∀a. Int -> a -> a
-- unfoldrStr : (seed -> Next a seed) -> seed -> Array a

-- Cases:
-- | Lift all alt functions:
--  (generalise , free vars , dups/eras , specs)
-- | Alt args lens into the scrut
-- * caseTypes: | LitTables | if-else | switch
-- * subtype sumTypes (ensure alts are subtyped to case-ret-type)

--f = \case
--  @Rectangle x y => add x y

--x = True
--y = @Rectangle 5 3
--either = \case
--  @Left a  => add a 2
--  @Right b => add b 5
